Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_v3_r/model_engine':
===============================================================================
  R/00_contracts_and_spec.R
  R/01_data_adapter.R
  R/02_risk_engine.R
  R/03_signal_engine.R
  R/04_state_and_gating.R
  R/05_portfolio_constructor.R
  R/06_snapshot_runner.R



###############################################################################
### FILE: R/00_contracts_and_spec.R
###############################################################################
#' @title Model Engine Contracts and Specs
#' @description Define contracts, validators, enums, spec defaults, and shared structural helpers.

#' @export
`%||%` <- function(a, b) if (is.null(a)) b else a

#' @export
me_require <- function(pkgs) {
    for (pkg in pkgs) {
        if (!requireNamespace(pkg, quietly = TRUE)) {
            stop(sprintf("Package '%s' is strictly required but not installed.", pkg), call. = FALSE)
        }
    }
}

#' @export
me_spec_default <- function() {
    list(
        data = list(
            min_coverage_ratio = 0.9,
            min_median_turnover = 1e5,
            allowed_types = c("equity", "unit")
        ),
        risk = list(
            vol = list(lookback = 63L),
            pca = list(lookback = 252L, k = 3L),
            resid = list(use_glasso = TRUE, lambda = 0.05),
            factor = list(),
            hrp = list()
        ),
        signals = list(
            kalman = list(lookback = 252L, q_var = 1e-4, r_var = 1e-2, scale = 1.0),
            tsmom = list(horizon = 252L, scale = 2.0)
        ),
        market_state = list(
            dispersion = list(lookback = 1L),
            eta = list(lookback = 63L),
            vov = list(lookback = 126L) # Note: requires R window of L + vol_lookback
        ),
        gating = list(
            w0 = c(kalman = 0, tsmom = 0, cash = -1),
            W = NULL
        ),
        portfolio = list(
            tilt = list(max_tilt = 2.0),
            caps = list(max_weight = 0.15)
        ),
        meta = list(
            retain_windows = TRUE,
            retain_matrices = TRUE
        )
    )
}

#' @export
me_get_spec <- function(overrides = NULL) {
    spec <- me_spec_default()
    if (!is.null(overrides)) {
        spec <- utils::modifyList(spec, overrides)
    }
    spec
}

#' @export
me_validate_spec <- function(spec) {
    req_names <- c("data", "risk", "signals", "market_state", "gating", "portfolio", "meta")
    missing <- setdiff(req_names, names(spec))
    if (length(missing) > 0) stop("ModelSpec missing sections: ", paste(missing, collapse = ", "))

    # Validate scalar domains
    if (!is.null(spec$portfolio$caps$max_weight) &&
        (spec$portfolio$caps$max_weight <= 0 || spec$portfolio$caps$max_weight > 1)) {
        stop("portfolio$caps$max_weight must be in (0, 1]")
    }

    if (!is.null(spec$data$min_coverage_ratio) &&
        (spec$data$min_coverage_ratio < 0 || spec$data$min_coverage_ratio > 1)) {
        stop("data$min_coverage_ratio must be in [0, 1]")
    }

    # Validate lookbacks
    for (mod in c("vol", "pca")) {
        if (!is.null(spec$risk[[mod]]$lookback) && spec$risk[[mod]]$lookback <= 0) {
            stop(sprintf("risk$%s$lookback must be positive", mod))
        }
    }

    if (!is.null(spec$risk$pca$k) && spec$risk$pca$k < 1) {
        stop("risk$pca$k must be >= 1")
    }

    if (!is.null(spec$risk$resid$lambda) && spec$risk$resid$lambda < 0) {
        stop("risk$resid$lambda must be >= 0")
    }

    if (!is.null(spec$signals$kalman$q_var) && spec$signals$kalman$q_var <= 0) {
        stop("signals$kalman$q_var must be > 0")
    }

    if (!is.null(spec$signals$kalman$r_var) && spec$signals$kalman$r_var <= 0) {
        stop("signals$kalman$r_var must be > 0")
    }

    # Validate gating parameter shapes
    w0 <- spec$gating$w0
    if (is.null(w0) || length(w0) != 3 || !all(c("kalman", "tsmom", "cash") %in% names(w0))) {
        stop("gating$w0 must be a 3-element vector named c('kalman', 'tsmom', 'cash')")
    }

    W <- spec$gating$W
    if (!is.null(W)) {
        expected_state_names <- c("disp", "eta", "VoV")
        if (nrow(W) != 3 || ncol(W) != length(expected_state_names)) {
            stop("gating$W must be a 3 x 3 matrix")
        }
        if (!all(rownames(W) == c("kalman", "tsmom", "cash"))) {
            stop("gating$W rownames must be exactly c('kalman', 'tsmom', 'cash')")
        }
        if (!all(colnames(W) == expected_state_names)) {
            stop("gating$W colnames must be exactly c('disp', 'eta', 'VoV')")
        }
    }

    invisible(spec)
}

#' @export
me_validate_snapshot_artifact <- function(x) {
    req_names <- c(
        "as_of_date", "tradable_symbols", "target_weights", "cash_weight",
        "risk", "signals", "market_state", "gating", "portfolio_diag", "meta", "warnings"
    )
    missing <- setdiff(req_names, names(x))
    if (length(missing) > 0) stop("SnapshotArtifact missing sections: ", paste(missing, collapse = ", "))

    if (!inherits(x$as_of_date, "Date")) stop("as_of_date must be a Date")

    # Target bounds
    tgt <- x$target_weights
    if (!is.data.frame(tgt)) stop("target_weights must be a data.frame")
    if (!all(c("symbol", "weight_target") %in% names(tgt))) {
        stop("target_weights must have 'symbol' and 'weight_target'")
    }
    if (length(unique(tgt$symbol)) != nrow(tgt)) stop("Duplicate symbols in target_weights")
    if (any(tgt$weight_target < 0, na.rm = TRUE)) stop("Negative target weights are not allowed")

    if (!is.numeric(x$cash_weight) || length(x$cash_weight) != 1 ||
        x$cash_weight < -1e-6 || x$cash_weight > 1 + 1e-6) {
        stop("cash_weight must be scalar in [0,1]")
    }

    tot_w <- sum(tgt$weight_target, na.rm = TRUE) + x$cash_weight
    if (abs(tot_w - 1.0) > 1e-4) stop(sprintf("Weights sum to %f, not 1.0", tot_w))

    # Gating consistency (if present)
    gating <- x$gating
    if (length(gating) > 0) {
        req_g <- c("w_kalman", "w_tsmom", "w_cash", "gross_exposure")
        if (!all(req_g %in% names(gating))) {
            stop("Gating artifact missing required fields")
        }
        if (abs(gating$gross_exposure - (1 - gating$w_cash)) > 1e-6) {
            stop("Gating consistency: gross_exposure != 1 - w_cash")
        }
        sum_gates <- gating$w_kalman + gating$w_tsmom + gating$w_cash
        if (abs(sum_gates - 1.0) > 1e-6) {
            stop("Gating consistency: softmax weights do not sum to 1")
        }
    }

    # Risk consistency (only validate matrices if retained/present)
    risk <- x$risk
    if (length(risk) > 0) {
        if (!is.null(risk$w_hrp)) {
            risk_univ <- names(risk$w_hrp)
            if (length(risk_univ) > 0 && !all(tgt$symbol %in% risk_univ)) {
                stop("Portfolio target universe contains elements not in canonical risk universe")
            }
        }

        if (!is.null(risk$sigma_t) && !is.null(risk$Sigma_total)) {
            if (is.null(rownames(risk$Sigma_total)) || is.null(colnames(risk$Sigma_total))) {
                stop("Sigma_total must have row/col names when retained")
            }
            if (!all(names(risk$sigma_t) == rownames(risk$Sigma_total))) {
                stop("Risk artifact mismatch: sigma_t names do not align with Sigma_total rownames")
            }
            if (!is.null(risk$w_hrp) && !all(names(risk$w_hrp) == colnames(risk$Sigma_total))) {
                stop("Risk artifact mismatch: w_hrp names do not align with Sigma_total colnames")
            }
        }
    }

    invisible(x)
}

#' @export
me_hash_spec <- function(spec) {
    me_require("digest")
    digest::digest(spec)
}



###############################################################################
### FILE: R/01_data_adapter.R
###############################################################################
#' @title Model Data Adapter
#' @description Wrap data bundle/panel securely into no-lookahead structures.

#' @export
me_make_data_adapter <- function(data_bundle_or_panel, aux = list()) {
    me_require("data.table")

    # Extract true panel
    if (is.list(data_bundle_or_panel) && "panel_adj_model" %in% names(data_bundle_or_panel)) {
        dt <- data.table::as.data.table(data_bundle_or_panel$panel_adj_model)
    } else if (is.data.frame(data_bundle_or_panel)) {
        dt <- data.table::as.data.table(data_bundle_or_panel)
    } else {
        stop("data_bundle_or_panel must be a data.frame or a bundle list containing 'panel_adj_model'")
    }

    req_cols <- c("symbol", "refdate", "open", "close", "turnover", "qty", "asset_type")
    missing <- setdiff(req_cols, names(dt))
    if (length(missing) > 0) stop("Panel missing fields: ", paste(missing, collapse = ", "))

    # Canonical refdate type
    if (!inherits(dt$refdate, "Date")) {
        # Try safe coercion once
        dt[, refdate := as.Date(refdate)]
        if (any(is.na(dt$refdate))) {
            stop("refdate must be coercible to Date without NA introduction")
        }
    }

    # Canonicalize
    data.table::setkeyv(dt, c("symbol", "refdate"))
    if (anyDuplicated(dt, by = c("symbol", "refdate")) > 0) {
        stop("Panel contains duplicate (symbol, refdate) pairs")
    }

    adapter <- list()

    adapter$calendar <- function() {
        sort(unique(dt$refdate))
    }

    adapter$panel_upto <- function(as_of_date) {
        dt[refdate <= as_of_date]
    }

    adapter$price_matrix <- function(as_of_date, lookback, field = "close", symbols = NULL, strict = TRUE) {
        sub_dt <- adapter$panel_upto(as_of_date)
        if (nrow(sub_dt) == 0) {
            return(matrix(NA_real_, 0, 0))
        }
        cal_upto <- sort(unique(sub_dt$refdate))
        dates_to_keep <- tail(cal_upto, lookback)
        sub_dt <- sub_dt[refdate %in% dates_to_keep]

        if (!is.null(symbols)) sub_dt <- sub_dt[symbol %in% symbols]

        mat <- data.table::dcast(sub_dt, refdate ~ symbol, value.var = field)
        if (nrow(mat) == 0) {
            return(matrix(NA_real_, 0, 0))
        }

        mat_out <- as.matrix(mat[, -1, with = FALSE])
        rownames(mat_out) <- as.character(mat$refdate)

        if (strict) {
            keep <- colSums(!is.na(mat_out)) == nrow(mat_out)
            mat_out <- mat_out[, keep, drop = FALSE]
        }

        # Return with requested symbol order if provided and possible
        if (!is.null(symbols)) {
            found <- intersect(symbols, colnames(mat_out))
            mat_out <- mat_out[, found, drop = FALSE]
        }
        mat_out
    }

    adapter$returns_matrix <- function(as_of_date, lookback, field = "close", method = "log", symbols = NULL, strict = TRUE) {
        pm <- adapter$price_matrix(as_of_date, lookback + 1, field, symbols, strict)
        if (nrow(pm) < 2) {
            return(matrix(NA_real_, nrow = 0, ncol = ncol(pm), dimnames = list(NULL, colnames(pm))))
        }
        if (method == "log") {
            diff(log(pm))
        } else {
            diff(pm) / pm[-nrow(pm), ]
        }
    }

    adapter$execution_price <- function(exec_date, field = "open", symbols = NULL) {
        sub_dt <- dt[refdate == exec_date]
        if (!is.null(symbols)) sub_dt <- sub_dt[symbol %in% symbols]
        res <- sub_dt[[field]]
        names(res) <- sub_dt$symbol
        if (!is.null(symbols)) {
            out <- rep(NA_real_, length(symbols))
            names(out) <- symbols
            found <- intersect(symbols, names(res))
            out[found] <- res[found]
            return(out)
        }
        res
    }

    adapter$investability_snapshot <- function(as_of_date, spec_data) {
        sub_dt <- adapter$panel_upto(as_of_date)
        cal_upto <- sort(unique(sub_dt$refdate))

        # Needs at least 63 days of history to check coverage reasonably, otherwise take available
        lkb <- min(63L, length(cal_upto))
        if (lkb < 5) {
            return(character(0))
        }

        dates_to_keep <- tail(cal_upto, lkb)
        sub_dt <- sub_dt[refdate %in% dates_to_keep]

        min_cov <- spec_data$min_coverage_ratio %||% 0.90
        min_turnover <- spec_data$min_median_turnover %||% 1e5
        allowed_types <- spec_data$allowed_types %||% c("equity")

        # Filter by type first
        if (length(allowed_types) > 0 && "asset_type" %in% names(sub_dt)) {
            sub_dt <- sub_dt[asset_type %in% allowed_types]
        }

        # Aggregate over the lookback
        agg <- sub_dt[, .(
            n_obs = .N,
            med_turnover = median(turnover, na.rm = TRUE),
            last_price = tail(close, 1)
        ), by = symbol]

        # Filter
        agg <- agg[n_obs >= (lkb * min_cov) & med_turnover >= min_turnover & last_price > 0]
        agg$symbol
    }

    adapter
}



###############################################################################
### FILE: R/02_risk_engine.R
###############################################################################
#' @title Risk Engine
#' @description Risk estimation and baseline allocation logic.

#' @export
me_estimate_vol <- function(R_window, spec_risk_vol) {
    vols <- apply(R_window, 2, sd, na.rm = TRUE) * sqrt(252)
    vols
}

#' @export
me_fit_pca_factor <- function(R_window, spec_pca) {
    me_require("Matrix")
    k <- spec_pca$k %||% 3
    k <- min(k, ncol(R_window))

    # Center, NO SCALING. Track means.
    c_means <- colMeans(R_window, na.rm = TRUE)
    R_centered <- scale(R_window, center = c_means, scale = FALSE)

    # PCA on centered returns
    pca <- prcomp(R_centered, center = FALSE, scale. = FALSE)

    B <- pca$rotation[, 1:k, drop = FALSE]
    F <- pca$x[, 1:k, drop = FALSE]

    list(B = B, F = F, sdev = pca$sdev, centers = c_means)
}

#' @export
me_residualize_returns <- function(R_window, pca_fit) {
    # Reconstruct and subtract in raw space
    R_centered <- scale(R_window, center = pca_fit$centers, scale = FALSE)

    # Systematic = F %*% t(B)
    Sys <- pca_fit$F %*% t(pca_fit$B)

    E <- R_centered - Sys
    dimnames(E) <- dimnames(R_window)
    E
}

#' @export
me_fit_residual_cov <- function(E_window, spec_resid) {
    use_glasso <- isTRUE(spec_resid$use_glasso)
    lambda <- spec_resid$lambda %||% 0.1

    if (use_glasso) {
        me_require("glasso")
    }

    # Sample residual covariance
    Sigma_eps <- cov(E_window, use = "pairwise.complete.obs")
    if (is.null(Sigma_eps) || any(!is.finite(Sigma_eps))) {
        stop("Residual covariance contains non-finite values.")
    }

    # Ensure dimnames from residual matrix columns
    dn <- list(colnames(E_window), colnames(E_window))
    dimnames(Sigma_eps) <- dn

    # Basic diagonal regularization before any inversion/optimization
    d <- diag(Sigma_eps)
    if (any(!is.finite(d)) || any(d <= 0)) {
        bad <- !is.finite(d) | d <= 0
        med_d <- median(d[is.finite(d) & d > 0], na.rm = TRUE)
        if (!is.finite(med_d) || med_d <= 0) med_d <- 1e-6
        d[bad] <- med_d
        diag(Sigma_eps) <- d
    }

    precision <- NULL

    if (use_glasso) {
        gl <- glasso::glasso(Sigma_eps, rho = lambda)
        Sigma_eps <- gl$w
        precision <- gl$wi
        dimnames(Sigma_eps) <- dn
        dimnames(precision) <- dn
    } else {
        ridge <- lambda * mean(diag(Sigma_eps), na.rm = TRUE)
        if (!is.finite(ridge) || ridge < 0) ridge <- 0
        diag(Sigma_eps) <- diag(Sigma_eps) + ridge
    }

    list(sigma_eps = Sigma_eps, precision = precision)
}

#' @export
me_factor_cov <- function(F_window, spec_factor_cov) {
    sigma_f <- cov(F_window, use = "pairwise.complete.obs")
    list(sigma_f = sigma_f)
}

#' @export
me_assemble_total_cov <- function(pca_fit, Sigma_f, Sigma_eps) {
    B <- pca_fit$B
    Sigma_total <- B %*% Sigma_f %*% t(B) + Sigma_eps
    dimnames(Sigma_total) <- dimnames(Sigma_eps)
    Sigma_total
}

#' @export
me_cov_sanity <- function(Sigma, repair = TRUE) {
    me_require("Matrix")
    repaired <- FALSE
    if (!isSymmetric(Sigma)) {
        Sigma <- (Sigma + t(Sigma)) / 2
        repaired <- TRUE
    }

    eig <- eigen(Sigma, symmetric = TRUE, only.values = TRUE)$values
    if (any(eig <= 0) || any(is.na(eig))) {
        if (repair) {
            Sigma <- as.matrix(Matrix::nearPD(Sigma, corr = FALSE, ensureSymmetry = TRUE)$mat)
            repaired <- TRUE
        }
    }
    list(is_valid = !any(eigen(Sigma)$values <= 0), repaired = repaired, Sigma = Sigma)
}

.inv_var_alloc <- function(cov_mat) {
    v <- diag(cov_mat)
    v[v <= 1e-8] <- 1e-8
    w <- 1 / v
    w / sum(w)
}

.get_cluster_var <- function(cov_mat, c_ix) {
    cov_slice <- cov_mat[c_ix, c_ix, drop = FALSE]
    w <- .inv_var_alloc(cov_slice)
    v <- sum(w * (cov_slice %*% w))
    if (v <= 0) v <- 1e-8
    v
}

.get_rec_bipart <- function(cov_mat, sort_ix) {
    w <- rep(1, length(sort_ix))
    names(w) <- colnames(cov_mat)[sort_ix]

    clusters <- list(sort_ix)
    while (length(clusters) > 0) {
        c_ix <- clusters[[1]]
        clusters <- clusters[-1]

        if (length(c_ix) > 1) {
            split_idx <- floor(length(c_ix) / 2)
            c1 <- c_ix[1:split_idx]
            c2 <- c_ix[(split_idx + 1):length(c_ix)]

            v1 <- .get_cluster_var(cov_mat, c1)
            v2 <- .get_cluster_var(cov_mat, c2)

            alpha <- 1 - v1 / (v1 + v2)
            w[c1] <- w[c1] * alpha
            w[c2] <- w[c2] * (1 - alpha)

            clusters <- append(clusters, list(c1, c2))
        }
    }
    return(w)
}

#' @export
me_allocate_hrp <- function(Sigma, spec_hrp) {
    n <- ncol(Sigma)
    if (is.null(n) || n == 0) {
        return(numeric(0))
    }
    if (n == 1) {
        w <- 1.0
        names(w) <- colnames(Sigma)
        return(w)
    }

    # Symmetrize defensively
    Sigma <- (Sigma + t(Sigma)) / 2

    # Safe correlation conversion
    s <- sqrt(pmax(diag(Sigma), 1e-12))
    R <- Sigma / (s %o% s)

    # Numerical cleanup
    R[!is.finite(R)] <- 0
    R <- (R + t(R)) / 2
    diag(R) <- 1
    R <- pmin(pmax(R, -1), 1)

    # Distance for HRP clustering
    D <- 0.5 * (1 - R)
    D[!is.finite(D)] <- 0
    D[D < 0] <- 0
    diag(D) <- 0

    dist_mat <- sqrt(D)

    hc <- tryCatch(
        hclust(as.dist(dist_mat), method = "single"),
        error = function(e) NULL
    )

    if (is.null(hc)) {
        w <- .inv_var_alloc(Sigma)
        names(w) <- colnames(Sigma)
        return(w)
    }

    sort_ix <- hc$order
    w_hrp <- .get_rec_bipart(Sigma, sort_ix)
    w_hrp[colnames(Sigma)]
}

#' @export
me_run_risk_engine <- function(R_window, spec_risk) {
    # Drop assets with insufficient data (e.g. any NAs inside the required window)
    keep_assets <- colSums(is.na(R_window)) == 0
    R_clean <- R_window[, keep_assets, drop = FALSE]

    if (ncol(R_clean) < 2) {
        stop("Risk engine needs >= 2 assets without missing data in risk lookback.")
    }

    vols <- me_estimate_vol(R_clean, spec_risk$vol)
    pca_fit <- me_fit_pca_factor(R_clean, spec_risk$pca)
    E <- me_residualize_returns(R_clean, pca_fit)
    resid_res <- me_fit_residual_cov(E, spec_risk$resid)
    Sigma_eps <- resid_res$sigma_eps
    Theta_eps <- resid_res$precision

    fac_res <- me_factor_cov(pca_fit$F, spec_risk$factor)
    Sigma_f <- fac_res$sigma_f

    Sigma_total <- me_assemble_total_cov(pca_fit, Sigma_f, Sigma_eps)
    sanity <- me_cov_sanity(Sigma_total, repair = TRUE)
    Sigma_repaired <- sanity$Sigma

    w_hrp <- me_allocate_hrp(Sigma_repaired, spec_risk$hrp)

    list(
        sigma_t = vols,
        B_t = pca_fit$B,
        F_t = pca_fit$F,
        E_t = E,
        Sigma_f = Sigma_f,
        Sigma_eps = Sigma_eps,
        Theta_eps = Theta_eps,
        Sigma_total = Sigma_repaired,
        w_hrp = w_hrp,
        diag = list(
            was_repaired = sanity$repaired,
            kept_assets = colnames(R_clean),
            dropped_assets = setdiff(colnames(R_window), colnames(R_clean))
        )
    )
}



###############################################################################
### FILE: R/03_signal_engine.R
###############################################################################
#' @title Signal Engine
#' @description Implement trend experts and score normalization in one place.

.tanh_scale <- function(x, scale = 1.0) {
  tanh(x / scale)
}

#' @export
me_signal_kalman <- function(prices_window, sigma_t, spec_kalman) {
  # 2-state local linear trend Kalman filter on log-prices
  # State x_t = [level_t, slope_t]'
  # level_t = level_{t-1} + slope_{t-1} + w1_t
  # slope_t = slope_{t-1} + w2_t
  # y_t = level_t + v_t

  n_assets <- ncol(prices_window)
  Tn <- nrow(prices_window)

  scores <- rep(0, n_assets)
  names(scores) <- colnames(prices_window)

  if (is.null(n_assets) || n_assets == 0 || Tn < 10) {
    return(scores)
  }

  q_var <- spec_kalman$q_var %||% 1e-4
  r_var <- spec_kalman$r_var %||% 1e-2
  out_scale <- spec_kalman$scale %||% 1.0

  # Correct local linear trend transition / observation matrices
  F_mat <- matrix(c(
    1, 1,
    0, 1
  ), nrow = 2, byrow = TRUE)
  H_mat <- matrix(c(1, 0), nrow = 1)

  Q <- diag(c(q_var, q_var))
  R_obs <- r_var

  I2 <- diag(2)

  for (j in seq_len(n_assets)) {
    y_raw <- prices_window[, j]

    # Require finite positive prices before log
    valid <- is.finite(y_raw) & !is.na(y_raw) & (y_raw > 0)
    if (sum(valid) < 10) next

    y <- log(y_raw[valid])

    # Initialize state
    x_hat <- matrix(c(y[1], 0), nrow = 2)
    P <- diag(c(1, 1))

    for (i in 2:length(y)) {
      # Predict
      x_pred <- F_mat %*% x_hat
      P_pred <- F_mat %*% P %*% t(F_mat) + Q

      # Update
      y_hat <- (H_mat %*% x_pred)[1, 1]
      err <- y[i] - y_hat
      S <- (H_mat %*% P_pred %*% t(H_mat))[1, 1] + R_obs

      if (!is.finite(S) || S <= 0) next

      K <- P_pred %*% t(H_mat) / S
      x_hat <- x_pred + K * err

      # Joseph-form covariance update (more numerically stable)
      KH <- K %*% H_mat
      P <- (I2 - KH) %*% P_pred %*% t(I2 - KH) + K %*% matrix(R_obs, 1, 1) %*% t(K)
    }

    # Final latent slope is a daily log-return-like increment
    slope_daily <- x_hat[2, 1]
    if (!is.finite(slope_daily)) next

    # Convert to annualized slope to match annualized sigma_t
    slope_ann <- slope_daily * 252

    sym_j <- colnames(prices_window)[j]
    vol_j <- sigma_t[sym_j]
    if (length(vol_j) != 1 || !is.finite(vol_j) || vol_j <= 0) {
      vol_j <- median(sigma_t[is.finite(sigma_t) & sigma_t > 0], na.rm = TRUE)
      if (!is.finite(vol_j) || vol_j <= 0) vol_j <- 0.2
    }

    scores[j] <- slope_ann / vol_j
  }

  .tanh_scale(scores, out_scale)
}

#' @export
me_signal_tsmom <- function(R_window, sigma_t, spec_tsmom) {
  h <- spec_tsmom$horizon %||% 252
  h <- min(h, nrow(R_window))

  if (h < 5) {
    v <- rep(0, ncol(R_window))
    names(v) <- colnames(R_window)
    return(v)
  }

  ret_cum <- apply(tail(R_window, h), 2, sum, na.rm = TRUE)

  scores_raw <- ret_cum / (sigma_t * sqrt(h / 252))
  scores_raw[is.na(scores_raw) | is.infinite(scores_raw)] <- 0

  .tanh_scale(scores_raw, spec_tsmom$scale %||% 2.0)
}

#' @export
me_align_signal_vectors <- function(...) {
  lst <- list(...)
  syms <- unique(unlist(lapply(lst, names)))

  aligned <- lapply(lst, function(v) {
    res <- rep(0, length(syms))
    names(res) <- syms
    idx <- intersect(names(v), syms)
    res[idx] <- v[idx]
    res
  })
  aligned
}

#' @export
me_run_signal_engine <- function(prices_window, R_window, sigma_t, spec_signals) {
  kalman_scores <- me_signal_kalman(prices_window, sigma_t, spec_signals$kalman)
  tsmom_scores <- me_signal_tsmom(R_window, sigma_t, spec_signals$tsmom)

  aligned <- me_align_signal_vectors(kalman = kalman_scores, tsmom = tsmom_scores)

  list(
    kalman = aligned$kalman, tsmom = aligned$tsmom,
    diag = list(
      kalman_coverage = sum(aligned$kalman != 0),
      tsmom_coverage = sum(aligned$tsmom != 0)
    )
  )
}



###############################################################################
### FILE: R/04_state_and_gating.R
###############################################################################
#' @title State and Gating
#' @description Compute market-state features and map them to expert trust and cash mass.

#' @export
me_state_dispersion <- function(r_t) {
    if (length(r_t) < 2) {
        return(0)
    }
    sd(r_t, na.rm = TRUE)
}

#' @export
me_state_mode_dominance <- function(R_state_window) {
    if (nrow(R_state_window) < 10) {
        return(0.5)
    }
    keep <- colSums(is.na(R_state_window)) == 0
    R_clean <- R_state_window[, keep, drop = FALSE]

    if (ncol(R_clean) < 2) {
        return(0.5)
    }

    pca <- tryCatch(prcomp(R_clean, center = TRUE, scale. = TRUE), error = function(e) NULL)
    if (is.null(pca)) {
        return(0.5)
    }

    vars <- pca$sdev^2
    vars[1] / sum(vars)
}

#' @export
me_state_vov <- function(R_hist, vol_lookback = 63L) {
    # True VoV: median market vol series standard deviation
    # R_hist must span (vov_lookback + vol_lookback - 1) days ideally

    n_days <- nrow(R_hist)
    if (n_days <= vol_lookback) {
        return(0)
    }

    # Rolling vol estimates per asset
    v_tau <- numeric(n_days - vol_lookback + 1)

    for (i in seq_along(v_tau)) {
        # window for t
        start_idx <- i
        end_idx <- i + vol_lookback - 1

        R_sub <- R_hist[start_idx:end_idx, , drop = FALSE]
        # Keep strictly valid columns inside this rolling slice
        keep <- colSums(is.na(R_sub)) == 0
        if (sum(keep) < 2) {
            v_tau[i] <- 0
            next
        }

        R_clean <- R_sub[, keep, drop = FALSE]
        # Volatility per asset in cross section
        vols <- apply(R_clean, 2, sd, na.rm = TRUE) * sqrt(252)
        # Market vol proxy on this day
        v_tau[i] <- median(vols, na.rm = TRUE)
    }

    # Return standard deviation of the median market vols over the state window
    sd(v_tau, na.rm = TRUE)
}

#' @export
me_build_market_state <- function(R_disp, R_eta, R_vov, spec_market_state, vol_lookback) {
    r_t <- tail(R_disp, 1)[1, ]
    res <- c(
        disp = me_state_dispersion(r_t),
        eta = me_state_mode_dominance(R_eta),
        VoV = me_state_vov(R_vov, vol_lookback)
    )
    # Ensure exact dimensions
    if (is.na(res["VoV"])) res["VoV"] <- 0
    res
}

#' @export
me_gating_softmax_linear <- function(m_t, spec_gating) {
    w0 <- spec_gating$w0 %||% c(kalman = 0, tsmom = 0, cash = -1)

    if (is.null(spec_gating$W)) {
        logits <- w0
    } else {
        # Safe alignment using exact parameter mapping established in validation
        logits <- w0 + as.vector(spec_gating$W %*% m_t[colnames(spec_gating$W)])
        names(logits) <- names(w0)
    }

    exp_logits <- exp(logits - max(logits))
    probs <- exp_logits / sum(exp_logits)

    list(
        w_kalman = probs["kalman"],
        w_tsmom = probs["tsmom"],
        w_cash = probs["cash"],
        gross_exposure = 1.0 - probs["cash"],
        logits = logits
    )
}

#' @export
me_run_state_and_gating <- function(R_disp, R_eta, R_vov, risk_artifact, spec_market_state, spec_gating, vol_lookback = 63L) {
    m_t <- me_build_market_state(R_disp, R_eta, R_vov, spec_market_state, vol_lookback)
    gating <- me_gating_softmax_linear(m_t, spec_gating)

    list(market_state = m_t, gating = gating)
}



###############################################################################
### FILE: R/05_portfolio_constructor.R
###############################################################################
#' @title Portfolio Constructor
#' @description Convert risk baseline + signals + gating into target weights.

#' @export
me_combine_expert_scores <- function(signal_artifact, gating_artifact, spec_portfolio) {
    wk <- gating_artifact$w_kalman
    wm <- gating_artifact$w_tsmom

    w_tot <- wk + wm
    if (w_tot == 0) {
        v <- signal_artifact$kalman * 0
        names(v) <- names(signal_artifact$kalman)
        return(v)
    }

    wk <- wk / w_tot
    wm <- wm / w_tot

    S_t <- (wk * signal_artifact$kalman) + (wm * signal_artifact$tsmom)
    S_t
}

#' @export
me_score_to_tilt <- function(S_t, spec_tilt) {
    # Formal cross-sectional standardisation and bounded tilt mapping
    max_tilt <- spec_tilt$max_tilt %||% 2.0

    mu <- mean(S_t, na.rm = TRUE)
    sigma <- sd(S_t, na.rm = TRUE)

    if (is.na(sigma) || sigma < 1e-8) {
        z_t <- S_t * 0
    } else {
        z_t <- (S_t - mu) / sigma
    }

    # Bounded sigmoid mapping
    lambda_tilt <- log(max_tilt)
    mult <- exp(lambda_tilt * tanh(z_t))

    list(mult = mult, z_t = z_t, mu = mu, sigma = sigma)
}

#' @export
me_apply_tilt_to_baseline <- function(w_hrp, tilt_mult, spec_portfolio) {
    # Align vectors
    mult_align <- rep(1.0, length(w_hrp))
    names(mult_align) <- names(w_hrp)
    found <- intersect(names(tilt_mult), names(w_hrp))
    mult_align[found] <- tilt_mult[found]

    w <- w_hrp * mult_align
    if (sum(w) > 0) w / sum(w) else w_hrp
}

#' @export
me_apply_weight_caps <- function(w, spec_caps) {
    cap <- spec_caps$max_weight %||% 0.15
    if (cap >= 1.0) {
        return(w)
    }

    if (length(w) * cap < 1.0) {
        # Cannot cap if mathematically impossible to sum to 1
        return(w)
    }

    # Iterative proportional redistribution
    for (iter in 1:100) {
        if (all(w <= cap + 1e-6)) break

        cap_idx <- w > cap
        excess <- sum(w[cap_idx] - cap)
        w[cap_idx] <- cap

        uncapped_idx <- w < cap
        if (sum(uncapped_idx) == 0) break

        # Redistribute proportionally to uncapped weights
        w_un <- w[uncapped_idx]
        if (sum(w_un) > 0) {
            w[uncapped_idx] <- w_un + excess * (w_un / sum(w_un))
        } else {
            w[uncapped_idx] <- w_un + excess / length(w_un)
        }
    }
    w / sum(w)
}

#' @export
me_build_portfolio_target <- function(risk_artifact, signal_artifact, state_gating_artifact, spec_portfolio, prev_target = NULL) {
    g_t <- state_gating_artifact$gating$gross_exposure
    w_hrp <- risk_artifact$w_hrp # canonical risk universe defines tradable subset

    # Extract scored elements strictly aligned with risk universe
    aligned_signals <- list(
        kalman = signal_artifact$kalman[names(w_hrp)],
        tsmom = signal_artifact$tsmom[names(w_hrp)]
    )
    # Missing -> Neutral (0)
    aligned_signals$kalman[is.na(aligned_signals$kalman)] <- 0
    aligned_signals$tsmom[is.na(aligned_signals$tsmom)] <- 0

    # Combine bounded signals into ensemble S_t
    S_t <- me_combine_expert_scores(aligned_signals, state_gating_artifact$gating, spec_portfolio)

    # Tilt computation: standardize S_t cross-sectionally and apply exponential tanh
    tilt_res <- me_score_to_tilt(S_t, spec_portfolio$tilt)
    tilt_mult <- tilt_res$mult

    w_tilted <- me_apply_tilt_to_baseline(w_hrp, tilt_mult, spec_portfolio)
    w_capped <- me_apply_weight_caps(w_tilted, spec_portfolio$caps)

    w_final_risky <- g_t * w_capped
    w_cash <- 1 - g_t

    w_final_risky[w_final_risky < 1e-4] <- 0

    tgt_table <- data.frame(
        symbol = names(w_final_risky),
        weight_target = unname(w_final_risky),
        stringsAsFactors = FALSE
    )

    tgt_table <- tgt_table[tgt_table$weight_target > 0, ]

    list(
        target_weights = tgt_table,
        cash_weight = w_cash,
        diag = list(
            score_mean = tilt_res$mu,
            score_sd = tilt_res$sigma,
            neutralized_scores = sum(S_t == 0),
            pre_norm_range = if (length(S_t) > 0) range(S_t, na.rm = TRUE) else c(0, 0),
            post_norm_range = if (length(tilt_res$z_t) > 0) range(tilt_res$z_t, na.rm = TRUE) else c(0, 0),
            cap_hits = sum(w_capped >= (spec_portfolio$caps$max_weight %||% 1) - 1e-4),
            pre_cap_sum = sum(w_tilted),
            post_cap_sum = sum(w_capped),
            gross_exposure = g_t
        )
    )
}



###############################################################################
### FILE: R/06_snapshot_runner.R
###############################################################################
#' @title Snapshot Runner
#' @description Orchestrate the full one-date modeling pipeline.

#' @export
me_run_snapshot <- function(data_bundle_or_panel, as_of_date, spec = NULL, prev_target = NULL, aux = list()) {
    spec <- me_get_spec(spec)
    me_validate_spec(spec)

    adapter <- me_make_data_adapter(data_bundle_or_panel, aux)

    cal <- adapter$calendar()
    if (!(as_of_date %in% cal)) {
        past_dates <- cal[cal <= as_of_date]
        if (length(past_dates) == 0) stop("No data before as_of_date")
        as_of_date <- max(past_dates)
    }

    syms <- adapter$investability_snapshot(as_of_date, spec$data)
    if (length(syms) == 0) {
        res_empty <- list(
            as_of_date = as_of_date,
            tradable_symbols = character(0),
            target_weights = data.frame(symbol = character(0), weight_target = numeric(0)),
            cash_weight = 1.0,
            risk = list(), signals = list(), market_state = list(), gating = list(), portfolio_diag = list(),
            meta = list(warns = "No tradable symbols"), warnings = character(0)
        )
        me_validate_snapshot_artifact(res_empty)
        return(res_empty)
    }

    # Module specific lookbacks
    lkb_kalman <- spec$signals$kalman$lookback %||% 252L
    lkb_tsmom <- spec$signals$tsmom$horizon %||% 252L
    lkb_risk <- max(spec$risk$vol$lookback %||% 252L, spec$risk$pca$lookback %||% 252L)
    lkb_disp <- spec$market_state$dispersion$lookback %||% 1L
    lkb_eta <- spec$market_state$eta$lookback %||% 63L
    lkb_vov <- spec$market_state$vov$lookback %||% 126L
    lkb_vol <- spec$risk$vol$lookback %||% 63L

    warns <- character(0)

    # vov depends on vol sequence spanning states
    max_lkb <- max(lkb_kalman, lkb_tsmom, lkb_risk, lkb_disp, lkb_eta, lkb_vov + lkb_vol - 1) + 1
    prices_max <- adapter$price_matrix(as_of_date, lookback = max_lkb, symbols = syms, strict = FALSE)
    ret_max <- adapter$returns_matrix(as_of_date, lookback = max_lkb - 1, symbols = syms, strict = FALSE)

    avail <- nrow(ret_max)
    if (avail < max_lkb - 1) {
        warns <- c(warns, sprintf("Global history (%d) is less than max requested lookback (%d)", avail, max_lkb - 1))
    }

    .slice_mat <- function(mat, n) {
        if (nrow(mat) < n) {
            return(mat)
        }
        tail(mat, n)
    }

    R_risk <- .slice_mat(ret_max, lkb_risk)
    P_kalman <- .slice_mat(prices_max, lkb_kalman)
    R_tsmom <- .slice_mat(ret_max, lkb_tsmom)
    R_disp <- .slice_mat(ret_max, lkb_disp)
    R_eta <- .slice_mat(ret_max, lkb_eta)
    R_vov <- .slice_mat(ret_max, lkb_vov + lkb_vol - 1)

    # Execute Risk Canonical Base First
    risk_artifact <- tryCatch(me_run_risk_engine(R_risk, spec$risk), error = function(e) {
        warns <<- c(warns, paste("Risk engine failed:", e$message))
        NULL
    })

    if (is.null(risk_artifact)) {
        res_err <- list(
            as_of_date = as_of_date,
            tradable_symbols = syms,
            target_weights = data.frame(symbol = character(0), weight_target = numeric(0)),
            cash_weight = 1.0,
            risk = list(), signals = list(), market_state = list(), gating = list(), portfolio_diag = list(),
            meta = list(), warnings = c(warns, "Reverting to cash position")
        )
        me_validate_snapshot_artifact(res_err)
        return(res_err)
    }

    # Exact alignment protocol: risk outputs govern the final cross-sectional universe
    risk_univ <- names(risk_artifact$w_hrp)
    sigma_t <- risk_artifact$sigma_t

    # Execute Signals and State using available data (subset cleanly downstream in portfolio)
    signal_artifact <- me_run_signal_engine(P_kalman, R_tsmom, sigma_t, spec$signals)

    state_gating_artifact <- me_run_state_and_gating(R_disp, R_eta, R_vov, risk_artifact, spec$market_state, spec$gating, vol_lookback = lkb_vol)

    port_artifact <- me_build_portfolio_target(risk_artifact, signal_artifact, state_gating_artifact, spec$portfolio, prev_target)

    if (nrow(port_artifact$target_weights) == 0 && port_artifact$cash_weight < 0.999) {
        warns <- c(warns, "Portfolio target has no risky weights but cash_weight < 1.0 (unexpected pruning/cap path).")
    }

    if (nrow(port_artifact$target_weights) == 0 && port_artifact$cash_weight >= 0.999) {
        warns <- c(warns, "Portfolio collapsed to cash (check gating logits, risk universe drops, and signal coverage).")
    }

    if (isFALSE(spec$meta$retain_windows)) {
        risk_artifact$E_t <- NULL
        risk_artifact$F_t <- NULL
    }
    if (isFALSE(spec$meta$retain_matrices)) {
        risk_artifact$Sigma_f <- NULL
        risk_artifact$Sigma_eps <- NULL
        risk_artifact$Theta_eps <- NULL
        risk_artifact$Sigma_total <- NULL
    }

    meta <- list(
        spec_hash = me_hash_spec(spec),
        universe_counts = list(
            investable = length(syms),
            risk_kept = length(risk_univ),
            risk_dropped = length(risk_artifact$diag$dropped_assets)
        ),
        lookbacks_used = list(
            kalman = lkb_kalman,
            tsmom = lkb_tsmom,
            risk = lkb_risk,
            vov_window = lkb_vov + lkb_vol - 1
        )
    )

    res <- list(
        as_of_date = as_of_date,
        tradable_symbols = syms,
        target_weights = port_artifact$target_weights,
        cash_weight = port_artifact$cash_weight,
        risk = risk_artifact,
        signals = signal_artifact,
        market_state = state_gating_artifact$market_state,
        gating = state_gating_artifact$gating,
        portfolio_diag = port_artifact$diag,
        meta = meta,
        warnings = warns
    )

    me_validate_snapshot_artifact(res)
    res
}



