Project structure for '/c/Users/Galaxy/LEVI/Projetos R/autofinance_v3_r/data_engine/R':
===============================================================================
  00_contracts.R
  01_config.R
  02_utils.R
  03_providers.R
  04_universe.R
  05_corp_actions.R
  06_adjuster.R
  07_diagnostics_features.R
  08_pipeline.R



###############################################################################
### FILE: 00_contracts.R
###############################################################################
# /data_engine/R/00_contracts.R

de_contracts <- list(
  universe_raw = c("symbol", "refdate", "asset_type", "open", "high", "low", "close", "turnover", "qty"),
  corp_actions_raw = c("symbol", "yahoo_symbol", "refdate", "action_type", "value", "source"),
  events_apply = c("symbol", "refdate", "split_value", "div_cash", "source_mask", "has_manual"),
  panel_adj_model = c("symbol", "refdate", "asset_type", "open", "high", "low", "close", "turnover", "qty", "adjustment_state"),
  panel_adj_debug = c("symbol", "refdate", "asset_type", "open_raw", "high_raw", "low_raw", "close_raw", "open_adj_split", "high_adj_split", "low_adj_split", "close_adj_split", "open", "high", "low", "close", "turnover", "qty", "adjustment_state")
)

de_assert_cols <- function(dt, cols, name = "object") {
  if (is.null(dt)) stop(name, " is NULL.", call. = FALSE)
  if (!is.data.frame(dt)) stop(name, " must be a data.frame/data.table.", call. = FALSE)
  miss <- setdiff(cols, names(dt))
  if (length(miss)) stop(name, " contract violation. Missing cols: ", paste(miss, collapse = ", "), call. = FALSE)
  invisible(TRUE)
}

de_assert_no_dupes <- function(dt, key_cols, name = "object") {
  if (!requireNamespace("data.table", quietly = TRUE)) stop("data.table required")
  x <- data.table::as.data.table(dt)
  dup <- x[, .N, by = key_cols][N > 1L]
  if (nrow(dup)) stop(name, " has duplicated keys on: ", paste(key_cols, collapse = ", "), call. = FALSE)
  invisible(TRUE)
}

# New: Strict Type, Domain enforcement, and Enum checks
de_enforce_types_and_domains <- function(dt, contract_name) {
  x <- data.table::as.data.table(dt)
  
  if ("symbol" %in% names(x)) if (!is.character(x$symbol)) stop(contract_name, "$symbol must be character")
  if ("refdate" %in% names(x)) if (!inherits(x$refdate, "Date")) stop(contract_name, "$refdate must be Date")
  
  # Ensure all OHLC are positive (not just close)
  ohlc <- intersect(c("open", "high", "low", "close"), names(x))
  for (col in ohlc) {
    if (any(x[[col]] <= 0, na.rm=TRUE)) stop(contract_name, " has zero/negative prices in ", col)
  }
  
  if ("asset_type" %in% names(x)) {
    if (!all(x$asset_type %in% c("equity", "fii", "etf", "bdr"))) stop("Invalid asset_type in ", contract_name)
  }
  
  if (contract_name == "events_apply") {
    if (any(x$split_value <= 0, na.rm=TRUE)) stop("events_apply has invalid split_value <= 0")
    if (any(x$div_cash < 0, na.rm=TRUE)) stop("events_apply has invalid div_cash < 0")
  }
  invisible(TRUE)
}

de_validate_contract <- function(dt, contract_name) {
  if (!contract_name %in% names(de_contracts)) stop("Unknown contract: ", contract_name, call. = FALSE)
  
  de_assert_cols(dt, de_contracts[[contract_name]], contract_name)
  de_enforce_types_and_domains(dt, contract_name)
  
  if (all(c("symbol", "refdate") %in% names(dt)) && contract_name != "corp_actions_raw") {
    de_assert_no_dupes(dt, c("symbol", "refdate"), contract_name)
    
    # FIX: Pure validation. Check sortedness without mutating (builders handle the actual sorting).
    if (is.unsorted(dt$symbol)) {
      stop(contract_name, " contract violation: not sorted by symbol.", call. = FALSE)
    }
  }
  invisible(TRUE)
}


###############################################################################
### FILE: 01_config.R
###############################################################################
# /data_engine/R/01_config.R

de_config_default <- function() {
  list(
    years = { y <- as.integer(format(Sys.Date(), "%Y")); (y-1L):y },
    include_types = c("equity", "fii", "etf", "bdr"),
    
    cache_dir  = "data/cache",
    raw_dir    = "data/raw",
    logs_dir   = "logs",
    
    min_turnover = 5e5,
    min_days_traded_ratio = 0.8,
    ca_prefilter_liq_window_days = 63L,
    
    # Audit gap flags (diagnostic only now)
    ca_prefilter_jump_log_thr = 1.0, 
    ca_prefilter_gap_equity = -0.20, 
    ca_prefilter_gap_fii    = -0.12,
    ca_prefilter_gap_etf    = -0.15,
    ca_prefilter_gap_bdr    = -0.20,
    
    ca_fetch_mode = "chart", 
    ca_cache_mode = "batch", 
    enable_manual_events = TRUE,
    
    enable_split_gap_validation = TRUE,
    split_gap_tol_log = 0.35,
    split_gap_max_forward_days = 5L,
    split_gap_max_back_days = 3L,
    split_gap_use_open = TRUE,
    
    adj_residual_jump_tol_log = 1.0,
    feature_horizons_days = c(21L, 63L, 126L, 252L)
  )
}

de_validate_config <- function(cfg) {
  if (!cfg$ca_cache_mode %in% c("batch", "by_symbol", "none")) {
    stop("Invalid ca_cache_mode. Must be 'batch', 'by_symbol', or 'none'.")
  }
  if (!cfg$ca_fetch_mode %in% c("chart", "quantmod")) {
    stop("Invalid ca_fetch_mode. Must be 'chart' or 'quantmod'.")
  }
  invisible(TRUE)
}

de_get_config <- function(overrides = NULL) {
  cfg <- de_config_default()
  if (!is.null(overrides)) {
    for (nm in names(overrides)) cfg[[nm]] <- overrides[[nm]]
  }
  
  de_validate_config(cfg)
  
  dir.create(cfg$cache_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$raw_dir, recursive = TRUE, showWarnings = FALSE)
  dir.create(cfg$logs_dir, recursive = TRUE, showWarnings = FALSE)
  
  cfg
}


###############################################################################
### FILE: 02_utils.R
###############################################################################
# /data_engine/R/02_utils.R

`%||%` <- function(x, y) if (!is.null(x)) x else y

de_require <- function(pkgs) {
  missing <- pkgs[!vapply(pkgs, requireNamespace, logical(1), quietly = TRUE)]
  if (length(missing)) {
    stop("Missing required packages for data engine: ", paste(missing, collapse = ", "), call. = FALSE)
  }
  invisible(TRUE)
}

de_log <- function(prefix, ...) {
  message(paste0(prefix, " ", paste(..., collapse = "")))
}

de_log_cfg <- function(cfg) {
  de_log("DE_CFG:", "\n", paste(utils::capture.output(str(cfg)), collapse = "\n"))
}

de_weekdays_only <- function(dates) {
  # 0 = Sunday, 6 = Saturday in POSIXlt
  w <- as.POSIXlt(dates)$wday
  w %in% 1:5
}

de_make_bizdays_seq <- function(start_date, end_date, cal = "Brazil/B3") {
  start_date <- as.Date(start_date)
  end_date   <- as.Date(end_date)
  
  if (requireNamespace("bizdays", quietly = TRUE)) {
    out <- tryCatch(bizdays::bizseq(start_date, end_date, cal), error = function(e) NULL)
    if (!is.null(out) && length(out)) return(as.Date(out))
  }
  
  d <- seq.Date(start_date, end_date, by = "day")
  d[de_weekdays_only(d)]
}


###############################################################################
### FILE: 03_providers.R
###############################################################################
# /data_engine/R/03_providers.R

# --- RB3 Provider ---
de_rb3_init <- function(cfg) {
  de_require("rb3")
  cache_dir <- file.path(cfg$cache_dir, "rb3")
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE)
  options(rb3.cachedir = normalizePath(cache_dir, winslash = "/", mustWork = FALSE))
  try(rb3::rb3_bootstrap(), silent = TRUE)
  invisible(TRUE)
}

de_rb3_fetch_yearly_lazy <- function(year, cfg, verbose = TRUE) {
  de_rb3_init(cfg)
  ok <- tryCatch({ rb3::fetch_marketdata("b3-cotahist-yearly", year = year, throttle = TRUE); TRUE }, error = function(e) FALSE)
  if (!ok) {
    try({ meta <- rb3::download_marketdata("b3-cotahist-yearly", year = year); rb3::read_marketdata(meta) }, silent = TRUE)
  }
  df <- rb3::cotahist_get("yearly")
  start_y <- as.Date(paste0(year, "-01-01"))
  end_y   <- as.Date(paste0(year + 1L, "-01-01"))
  dplyr::filter(df, refdate >= start_y, refdate < end_y)
}

de_rb3_fetch_window_lazy <- function(start_date, end_date, cfg, verbose = TRUE) {
  de_rb3_init(cfg)
  dates <- de_make_bizdays_seq(start_date, end_date)
  ok <- tryCatch({ rb3::fetch_marketdata("b3-cotahist-daily", refdate = dates, throttle = TRUE); TRUE }, error = function(e) FALSE)
  if (!ok) {
    for (d in dates) {
      try({ meta <- rb3::download_marketdata("b3-cotahist-daily", refdate = d); rb3::read_marketdata(meta) }, silent = TRUE)
    }
  }
  df <- rb3::cotahist_get("daily")
  dplyr::filter(df, refdate >= as.Date(start_date), refdate <= as.Date(end_date))
}

# --- Yahoo Provider ---
de_yahoo_symbol <- function(symbol) {
  s <- toupper(trimws(as.character(symbol)))
  if (is.na(s) || !nzchar(s)) return(NA_character_)
  if (grepl("\\.", s)) return(s)
  paste0(s, ".SA")
}

de_yahoo_with_retry <- function(fun, max_tries = 4L, base_sleep = 1.5, verbose = FALSE) {
  for (k in seq_len(max_tries)) {
    out <- tryCatch(fun(), error = function(e) e)
    if (!inherits(out, "error")) return(out)
    if (!grepl("429|Too Many Requests|rate limit", conditionMessage(out), ignore.case = TRUE)) return(NULL)
    if (k < max_tries) Sys.sleep(base_sleep * (2^(k - 1)) * runif(1, 0.8, 1.2))
  }
  NULL
}

de_yahoo_fetch_chart_events_one <- function(yahoo_symbol, from, to, verbose = FALSE) {
  empty_dt <- data.table::data.table(yahoo_symbol = character(), refdate = as.Date(character()), action_type = character(), value = numeric(), source = character())
  if (is.na(yahoo_symbol)) return(empty_dt)
  
  if (!requireNamespace("jsonlite", quietly=TRUE) || !requireNamespace("curl", quietly=TRUE)) return(empty_dt)
  
  p1 <- as.integer(as.POSIXct(as.Date(from), tz = "UTC"))
  p2 <- as.integer(as.POSIXct(as.Date(to) + 1, tz = "UTC"))
  url <- sprintf("https://query1.finance.yahoo.com/v8/finance/chart/%s?period1=%d&period2=%d&interval=1d&events=div%%7Csplits", utils::URLencode(yahoo_symbol, reserved = TRUE), p1, p2)
  
  h <- curl::new_handle()
  curl::handle_setheaders(h, "User-Agent" = "Mozilla/5.0", "Accept" = "application/json")
  
  fetch_once <- function() {
    resp <- curl::curl_fetch_memory(url, handle = h)
    if (resp$status_code == 429) stop("HTTP 429", call. = FALSE)
    if (resp$status_code == 404) return(NULL)
    if (resp$status_code >= 400) stop("HTTP ", resp$status_code, call. = FALSE)
    tryCatch(jsonlite::fromJSON(rawToChar(resp$content), simplifyVector = FALSE), error=function(e) NULL)
  }
  
  js <- de_yahoo_with_retry(fetch_once, max_tries = 4L)
  if (is.null(js) || is.null(js$chart$result[[1]]$events)) return(empty_dt)
  
  ev <- js$chart$result[[1]]$events
  out_list <- list()
  
  if (!is.null(ev$dividends)) {
    out_list[["dividend"]] <- data.table::rbindlist(lapply(ev$dividends, function(d) {
      if (is.null(d$date) || is.null(d$amount)) return(NULL)
      data.table::data.table(yahoo_symbol = yahoo_symbol, refdate = as.Date(as.POSIXct(as.integer(d$date), origin = "1970-01-01", tz = "UTC")), action_type = "dividend", value = as.numeric(d$amount), source = "yahoo")
    }), fill=TRUE)
  }
  
  if (!is.null(ev$splits)) {
    out_list[["split"]] <- data.table::rbindlist(lapply(ev$splits, function(s) {
      if (is.null(s$date) || is.null(s$numerator) || is.null(s$denominator)) return(NULL)
      pf <- as.numeric(s$denominator) / as.numeric(s$numerator) # Price Factor orientation
      data.table::data.table(yahoo_symbol = yahoo_symbol, refdate = as.Date(as.POSIXct(as.integer(s$date), origin = "1970-01-01", tz = "UTC")), action_type = "split", value = pf, source = "yahoo")
    }), fill=TRUE)
  }
  
  out <- data.table::rbindlist(out_list, fill = TRUE)
  if (nrow(out) > 0) return(out[is.finite(value) & value > 0 & !is.na(refdate)])
  empty_dt
}

de_yahoo_fetch_splits_quantmod_one <- function(ysym, from, to) {
  de_require("quantmod")
  x <- de_yahoo_with_retry(function() quantmod::getSplits(ysym, from=from, to=to, auto.assign=FALSE))
  if (is.null(x) || length(x) == 0 || (length(x) == 1 && is.na(as.numeric(x)))) return(NULL)
  
  # Note: quantmod getSplits already returns the price factor convention (e.g., 0.5 for 2:1)
  val <- as.numeric(zoo::coredata(x))
  dt <- data.table::data.table(yahoo_symbol = ysym, refdate = as.Date(zoo::index(x)), action_type = "split", value = val, source = "yahoo")
  dt[is.finite(value) & value > 0] # Ensure safe domain
}

de_yahoo_fetch_dividends_quantmod_one <- function(ysym, from, to) {
  de_require("quantmod")
  x <- de_yahoo_with_retry(function() quantmod::getDividends(ysym, from=from, to=to, auto.assign=FALSE, split.adjust=TRUE))
  if (is.null(x) || length(x) == 0) return(NULL)
  dt <- data.table::data.table(yahoo_symbol = ysym, refdate = as.Date(zoo::index(x)), action_type = "dividend", value = as.numeric(zoo::coredata(x)), source = "yahoo")
  dt[is.finite(value) & value >= 0]
}


###############################################################################
### FILE: 04_universe.R
###############################################################################
# /data_engine/R/04_universe.R

de_select_min_cols <- function(df) {
  de_require(c("data.table", "dplyr"))
  dt <- data.table::as.data.table(df)
  pick_col <- function(alts) { cand <- intersect(alts, names(dt)); if(length(cand)) cand[1] else NA_character_ }
  
  c_sym  <- pick_col(c("symbol", "ticker"))
  c_ref  <- pick_col(c("refdate", "date"))
  c_open <- pick_col(c("open", "price.open", "preco_abertura"))
  c_high <- pick_col(c("high", "price.high", "preco_maximo"))
  c_low  <- pick_col(c("low", "price.low", "preco_minimo"))
  c_close<- pick_col(c("close", "price.close", "preco_ultimo"))
  c_vol  <- pick_col(c("financial_volume", "volume", "vol_fin"))
  c_qty  <- pick_col(c("trade_quantity", "quantity", "qty"))
  
  if (any(is.na(c(c_sym, c_ref, c_close)))) stop("Missing core B3 columns in rb3 output.")
  
  data.table::data.table(
    symbol = toupper(trimws(as.character(dt[[c_sym]]))),
    refdate = as.Date(dt[[c_ref]]),
    open = if(!is.na(c_open)) as.numeric(dt[[c_open]]) else NA_real_,
    high = if(!is.na(c_high)) as.numeric(dt[[c_high]]) else NA_real_,
    low  = if(!is.na(c_low))  as.numeric(dt[[c_low]])  else NA_real_,
    close= as.numeric(dt[[c_close]]),
    vol_fin = if(!is.na(c_vol)) as.numeric(dt[[c_vol]]) else NA_real_,
    qty_raw = if(!is.na(c_qty)) as.numeric(dt[[c_qty]]) else NA_real_
  )
}

de_unify_liquidity <- function(dt) {
  dt[, qty := qty_raw]
  dt[, turnover := data.table::fifelse(
    is.finite(vol_fin) & vol_fin > 0, vol_fin,
    data.table::fifelse(is.finite(qty) & qty > 0 & is.finite(close), qty * close, NA_real_)
  )]
  dt[, c("vol_fin", "qty_raw") := NULL]
  dt
}

de_dedupe_symbol_date <- function(dt) {
  data.table::setorder(dt, asset_type, symbol, refdate)
  dup <- dt[, .N, by = .(symbol, refdate)][N > 1L]
  if (nrow(dup)) {
    if (!"turnover" %in% names(dt)) dt[, turnover := NA_real_]
    if (!"qty" %in% names(dt)) dt[, qty := NA_real_]
    dt <- dt[order(
      symbol, refdate,
      -data.table::fifelse(is.finite(turnover), turnover, -Inf),
      -data.table::fifelse(is.finite(qty), qty, -Inf),
      -data.table::fifelse(is.finite(close), close, -Inf)
    )][, .SD[1L], by = .(symbol, refdate)]
    data.table::setorder(dt, asset_type, symbol, refdate)
  }
  dt
}

de_process_rb3_lazy_df <- function(df_lazy, include_types) {
  out_list <- list()
  for (tp in include_types) {
    lazy_tp <- switch(tp,
      equity = tryCatch(rb3::cotahist_filter_equity(df_lazy), error=function(e) NULL),
      fii    = tryCatch(rb3::cotahist_filter_fii(df_lazy), error=function(e) NULL),
      etf    = tryCatch(rb3::cotahist_filter_etf(df_lazy), error=function(e) NULL),
      bdr    = tryCatch(rb3::cotahist_filter_bdr(df_lazy), error=function(e) NULL)
    )
    if (!is.null(lazy_tp)) {
      df_tp <- dplyr::collect(lazy_tp)
      if (nrow(df_tp)) {
        dt_tp <- de_select_min_cols(df_tp)
        dt_tp <- de_unify_liquidity(dt_tp)
        dt_tp[, asset_type := tp]
        out_list[[tp]] <- dt_tp
      }
    }
  }
  if (!length(out_list)) return(NULL)
  dt <- data.table::rbindlist(out_list, fill = TRUE)
  dt[!is.na(symbol) & nzchar(symbol) & !is.na(refdate) & is.finite(close) & close > 0]
}

de_build_universe_year <- function(year, include_types, cfg) {
  de_require("dplyr")
  df_lazy <- de_rb3_fetch_yearly_lazy(year, cfg)
  de_process_rb3_lazy_df(df_lazy, include_types)
}

# NEW: Missing window implementation
de_build_universe_window <- function(start_date, end_date, cfg) {
  de_require("dplyr")
  df_lazy <- de_rb3_fetch_window_lazy(start_date, end_date, cfg)
  dt <- de_process_rb3_lazy_df(df_lazy, cfg$include_types)
  if (is.null(dt)) stop("Universe window is empty.")
  
  dt <- de_dedupe_symbol_date(dt)
  de_validate_contract(dt, "universe_raw")
  dt
}

de_build_universe <- function(years, cfg) {
  res <- lapply(sort(unique(as.integer(years))), de_build_universe_year, include_types = cfg$include_types, cfg = cfg)
  res <- res[!vapply(res, is.null, logical(1))]
  if (!length(res)) stop("Universe is empty.")
  
  dt <- data.table::rbindlist(res, fill = TRUE)
  
  # NEW: Global dedupe and validation after merging years
  dt <- de_dedupe_symbol_date(dt)
  de_validate_contract(dt, "universe_raw")
  
  dt
}


###############################################################################
### FILE: 05_corp_actions.R
###############################################################################
# /data_engine/R/05_corp_actions.R

de_select_ca_candidates <- function(universe_raw, cfg, force_symbols = NULL) {
  dt <- data.table::as.data.table(universe_raw)
  end_date <- max(dt$refdate, na.rm = TRUE)
  liq_start <- end_date - ceiling(cfg$ca_prefilter_liq_window_days * 1.6)
  
  # 1) Calculate Candidate Universe (Strictly Modeling-Eligible names)
  dt_liq <- dt[refdate >= liq_start & refdate <= end_date]
  
  # FIX: Calculate ratio based on total unique market days in the window, not row count
  total_market_days <- length(unique(dt_liq$refdate))
  if (total_market_days == 0) total_market_days <- 1 
  
  stats_liq <- dt_liq[, .(
    med_turnover = stats::median(turnover, na.rm = TRUE),
    days_ratio = .N / total_market_days
  ), by = .(symbol, asset_type)]
  
  candidates <- stats_liq[med_turnover >= cfg$min_turnover & days_ratio >= cfg$min_days_traded_ratio]$symbol
  
  # FIX: Handle force_symbols inside the function so the audit table knows about them
  force_symbols <- unique(toupper(trimws(as.character(force_symbols))))
  force_symbols <- force_symbols[!is.na(force_symbols) & nzchar(force_symbols)]
  candidates <- unique(c(candidates, force_symbols))
  
  # 2) Calculate Diagnostic Prefilter Audit (Gap tracking)
  data.table::setorder(dt, symbol, refdate)
  dt[, close_lag := data.table::shift(close, 1L), by = symbol]
  dt[, log_ret := data.table::fifelse(close > 0 & close_lag > 0, log(close / close_lag), NA_real_)]
  dt[, ret_1d := (close / close_lag) - 1]
  
  thr_map <- data.table::data.table(
    asset_type = c("equity", "fii", "etf", "bdr"),
    thr = c(cfg$ca_prefilter_gap_equity, cfg$ca_prefilter_gap_fii, cfg$ca_prefilter_gap_etf, cfg$ca_prefilter_gap_bdr)
  )
  dt <- merge(dt, thr_map, by = "asset_type", all.x = TRUE)
  
  jump_pos <- dt[is.finite(log_ret) & log_ret >= cfg$ca_prefilter_jump_log_thr, unique(symbol)]
  jump_neg <- dt[is.finite(ret_1d) & is.finite(thr) & ret_1d <= thr, unique(symbol)]
  
  audit_dt <- data.table::data.table(symbol = unique(dt$symbol))
  audit_dt[, is_candidate := symbol %in% candidates]
  audit_dt[, is_forced := symbol %in% force_symbols]
  audit_dt[, has_positive_jump := symbol %in% jump_pos]
  audit_dt[, has_negative_gap := symbol %in% jump_neg]
  
  list(
    candidates = unique(candidates[!is.na(candidates) & nzchar(candidates)]),
    prefilter_audit = audit_dt
  )
}

de_build_ca_registry <- function(symbols, from, to, cfg) {
  de_require("data.table")
  
  # FIX: Only require 'digest' if we are actually using a cache mode
  if (cfg$ca_cache_mode %in% c("batch", "by_symbol")) {
    de_require("digest")
    hash_payload <- list(syms=sort(symbols), from=from, to=to, mode=cfg$ca_fetch_mode)
    batch_hash <- digest::digest(hash_payload)
  }
  
  cache_dir_ca <- file.path(cfg$cache_dir, "corp_actions")
  if (!dir.exists(cache_dir_ca)) dir.create(cache_dir_ca, recursive = TRUE)
  
  # Batch Cache mode check
  if (cfg$ca_cache_mode == "batch") {
    batch_file <- file.path(cache_dir_ca, paste0("ca_batch_", batch_hash, ".rds"))
    if (file.exists(batch_file)) {
      de_log("DE_CA:", "Loading from CA batch cache.")
      return(readRDS(batch_file))
    }
  }

  map_dt <- data.table::data.table(symbol = symbols, yahoo_symbol = vapply(symbols, de_yahoo_symbol, ""))
  map_dt <- map_dt[!is.na(yahoo_symbol)]
  
  res_list <- list()
  for (i in seq_len(nrow(map_dt))) {
    sym <- map_dt$symbol[i]
    ysym <- map_dt$yahoo_symbol[i]
    
    # By-Symbol Cache check
    if (cfg$ca_cache_mode == "by_symbol") {
      sym_hash <- digest::digest(list(sym=sym, from=from, to=to, mode=cfg$ca_fetch_mode))
      sym_file <- file.path(cache_dir_ca, paste0("sym_", sym, "_", sym_hash, ".rds"))
      if (file.exists(sym_file)) {
        res_list[[i]] <- readRDS(sym_file)
        next
      }
    }
    
    # Fetch
    if (cfg$ca_fetch_mode == "chart") {
      out <- de_yahoo_fetch_chart_events_one(ysym, from, to)
    } else {
      dt_s <- de_yahoo_fetch_splits_quantmod_one(ysym, from, to)
      dt_d <- de_yahoo_fetch_dividends_quantmod_one(ysym, from, to)
      out <- data.table::rbindlist(list(dt_s, dt_d), fill = TRUE)
    }
    
    if (!is.null(out) && nrow(out)) {
      out[, symbol := sym]
      if (cfg$ca_cache_mode == "by_symbol") saveRDS(out, sym_file)
      res_list[[i]] <- out
    }
  }
  
  dt <- data.table::rbindlist(res_list, fill = TRUE)
  if (!nrow(dt)) dt <- data.table::data.table(symbol=character(), yahoo_symbol=character(), refdate=as.Date(character()), action_type=character(), value=numeric(), source=character())
  else dt[, source := "yahoo"]
  
  de_validate_contract(dt, "corp_actions_raw")
  
  # Save batch cache if applicable
  if (cfg$ca_cache_mode == "batch" && nrow(dt)) {
    batch_file <- file.path(cache_dir_ca, paste0("ca_batch_", batch_hash, ".rds"))
    saveRDS(dt, batch_file)
  }
  
  dt
}

de_fix_yahoo_splits_by_raw_gap <- function(corp_actions_raw, universe_raw, cfg) {
  sp <- data.table::as.data.table(corp_actions_raw)
  dt <- data.table::as.data.table(universe_raw)
  if (!nrow(sp)) return(list(corp_actions_apply = sp, split_audit = data.table::data.table(), quarantine = data.table::data.table()))
  
  sp[, row_id := .I]
  to_val <- sp[action_type == "split" & source == "yahoo" & is.finite(value) & value > 0]
  if (!nrow(to_val)) return(list(corp_actions_apply = sp, split_audit = data.table::data.table(), quarantine = data.table::data.table()))
  
  data.table::setorder(dt, symbol, refdate)
  dt[, close_lag := data.table::shift(close, 1L), by = symbol]
  data.table::setkey(dt, symbol, refdate)
  
  offs <- seq.int(-cfg$split_gap_max_back_days, cfg$split_gap_max_forward_days)
  
  eval_one <- function(sym, vdate, vval) {
    best <- list(err = Inf, eff = as.Date(NA), chosen = NA_real_)
    for (o in offs) {
      d <- vdate + o
      row <- dt[.(sym, d), nomatch = 0L]
      if (nrow(row) != 1L || !is.finite(row$close_lag[[1]]) || row$close_lag[[1]] <= 0) next
      
      obs <- NA_real_
      if (cfg$split_gap_use_open && is.finite(row$open[[1]]) && row$open[[1]] > 0) {
        obs <- row$open[[1]] / row$close_lag[[1]]
      } else if (is.finite(row$close[[1]]) && row$close[[1]] > 0) {
        obs <- row$close[[1]] / row$close_lag[[1]]
      } else next
      
      for (cv in c(vval, 1/vval)) {
        if (!is.finite(cv) || cv <= 0) next
        e <- abs(log(obs) - log(cv))
        if (is.finite(e) && e < best$err) {
          best$err <- e; best$eff <- d; best$chosen <- cv
        }
      }
    }
    best
  }
  
  out <- to_val[, {
    b <- eval_one(symbol, refdate, value)
    st <- if (!is.finite(b$err) || is.na(b$eff)) "unverified" else if (b$err <= cfg$split_gap_tol_log) "kept" else "rejected"
    .(eff_refdate = b$eff, chosen_value = b$chosen, chosen_err = b$err, status = st)
  }, by = .(row_id, symbol, yahoo_symbol, vendor_refdate = refdate, action_type, value, source)]
  
  data.table::setorder(out, symbol, eff_refdate, chosen_value, chosen_err)
  out[, dup_rank := seq_len(.N), by = .(symbol, eff_refdate, chosen_value)]
  out[dup_rank > 1L & status == "kept", status := "dup"]
  
  kept <- out[status %in% c("kept", "unverified"), .(symbol, yahoo_symbol, refdate = data.table::fifelse(status=="kept", eff_refdate, vendor_refdate), action_type = "split", value = data.table::fifelse(status=="kept", chosen_value, value), source)]
  base_ca <- sp[!(action_type == "split" & source == "yahoo"), .(symbol, yahoo_symbol, refdate, action_type, value, source)]
  
  ca_apply <- data.table::rbindlist(list(base_ca, kept), fill = TRUE)
  ca_apply <- unique(ca_apply, by = c("symbol", "refdate", "action_type", "value", "source"))
  quar <- out[status %in% c("rejected", "dup")]
  
  list(corp_actions_apply = ca_apply, split_audit = out, quarantine = quar)
}

de_build_events <- function(corp_actions_apply, manual_events = NULL, cfg) {
  dt <- data.table::as.data.table(corp_actions_apply)
  
  # Honor cfg$enable_manual_events
  if (cfg$enable_manual_events && !is.null(manual_events)) {
    me <- data.table::as.data.table(manual_events)
    if (!"source" %in% names(me)) me[, source := "manual"]
    dt <- data.table::rbindlist(list(dt, me), fill = TRUE)
  }
  
  if (!nrow(dt)) return(data.table::data.table(symbol=character(), refdate=as.Date(character()), split_value=numeric(), div_cash=numeric(), source_mask=character(), has_manual=logical()))
  
  dt <- unique(dt, by = c("symbol", "refdate", "action_type", "value", "source"))
  
  sp <- dt[action_type == "split", .(split_value = prod(value, na.rm=TRUE), mask_s = paste(sort(unique(source)), collapse="+")), by=.(symbol, refdate)]
  di <- dt[action_type == "dividend", .(div_cash = sum(value, na.rm=TRUE), mask_d = paste(sort(unique(source)), collapse="+")), by=.(symbol, refdate)]
  
  ev <- merge(sp, di, by=c("symbol", "refdate"), all = TRUE)
  ev[is.na(split_value), split_value := 1]
  ev[is.na(div_cash), div_cash := 0]
  ev[, source_mask := data.table::fifelse(!is.na(mask_s) & !is.na(mask_d), paste0(mask_s, "+", mask_d), data.table::fifelse(!is.na(mask_s), mask_s, mask_d))]
  ev[, has_manual := grepl("manual", source_mask)]
  ev[, c("mask_s", "mask_d") := NULL]
  
  ev <- ev[is.finite(split_value) & split_value > 0 & is.finite(div_cash) & div_cash >= 0]
  de_validate_contract(ev, "events_apply")
  ev[order(symbol, refdate)]
}


###############################################################################
### FILE: 06_adjuster.R
###############################################################################
# /data_engine/R/06_adjuster.R

de_rev_cumprod_exclusive <- function(x) {
  if (!length(x)) return(x)
  data.table::shift(rev(cumprod(rev(x))), 1L, type = "lead", fill = 1)
}

de_apply_adjustments <- function(universe_raw, events_apply, cfg) {
  dt <- data.table::as.data.table(universe_raw)
  ev <- data.table::as.data.table(events_apply)
  
  data.table::setkey(dt, symbol, refdate)
  if (nrow(ev)) data.table::setkey(ev, symbol, refdate)
  
  if (nrow(ev)) dt <- merge(dt, ev, by=c("symbol", "refdate"), all.x=TRUE)
  if (!"split_value" %in% names(dt)) dt[, `:=`(split_value=1, div_cash=0, source_mask="none", has_manual=FALSE)]
  dt[is.na(split_value), split_value := 1]
  dt[is.na(div_cash), div_cash := 0]
  
  data.table::setorder(dt, symbol, refdate)
  
  # 1) Split Factor
  dt[, split_factor_cum := de_rev_cumprod_exclusive(split_value), by = symbol]
  dt[, `:=`(
    open_adj_split = open * split_factor_cum,
    high_adj_split = high * split_factor_cum,
    low_adj_split  = low  * split_factor_cum,
    close_adj_split= close* split_factor_cum
  )]
  
  # 2) Dividend Factor
  dt[, close_prev := data.table::shift(close_adj_split, 1L, type = "lag"), by = symbol]
  dt[, `:=`(div_factor_event = 1, issue_div = FALSE, div_cash_eff = div_cash)]
  
  # Dividend Rescue (Basis Mismatch)
  is_div <- dt$div_cash > 0
  need_scale <- is_div & is.finite(dt$close_prev) & dt$close_prev > 0 & 
                is.finite(dt$split_factor_cum) & dt$split_factor_cum > 0 & dt$split_factor_cum < 1 & 
                dt$div_cash >= dt$close_prev
  
  if (any(need_scale)) {
    idx <- which(need_scale)
    scaled <- dt$div_cash[idx] * dt$split_factor_cum[idx]
    ok <- is.finite(scaled) & scaled >= 0 & scaled < dt$close_prev[idx]
    if (any(ok)) dt[idx[ok], div_cash_eff := scaled[ok]]
  }
  
  # Apply Div
  bad_div <- is_div & (is.na(dt$close_prev) | dt$close_prev <= 0 | is.na(dt$div_cash_eff) | dt$div_cash_eff < 0 | dt$div_cash_eff >= dt$close_prev)
  if (any(bad_div)) dt[bad_div, issue_div := TRUE]
  
  good_div <- is_div & !bad_div
  if (any(good_div)) dt[good_div, div_factor_event := (close_prev - div_cash_eff) / close_prev]
  
  dt[, div_factor_cum := de_rev_cumprod_exclusive(div_factor_event), by = symbol]
  dt[, adj_factor_final := split_factor_cum * div_factor_cum]
  
  dt[, `:=`(
    open_adj_final  = open * adj_factor_final,
    high_adj_final  = high * adj_factor_final,
    low_adj_final   = low  * adj_factor_final,
    close_adj_final = close* adj_factor_final
  )]
  
  # Adjustments Timeline Audit
  tl <- dt[, .(symbol, refdate, split_value, div_cash, div_cash_eff, split_factor_cum, div_factor_event, div_factor_cum, adj_factor_final, source_mask, has_manual, issue_div)]
  list(panel = dt, adjustments_timeline = tl)
}

de_build_panel_adjusted <- function(universe_raw, events_apply, cfg) {
  res <- de_apply_adjustments(universe_raw, events_apply, cfg)
  dt <- res$panel
  tl <- res$adjustments_timeline
  
  # State Calculation
  st <- tl[, .(has_split = any(split_value != 1), has_div = any(div_cash > 0), has_manual = any(has_manual), issue_div_any = any(issue_div)), by = symbol]
  st[, adjustment_state := "no_actions"]
  st[has_div & !has_split, adjustment_state := "dividend_only"]
  st[has_split & !has_div, adjustment_state := "split_only"]
  st[has_split & has_div, adjustment_state := "split_dividend"]
  st[has_manual == TRUE, adjustment_state := "manual_override"]
  st[issue_div_any == TRUE, adjustment_state := "suspect_unresolved"]
  
  # Jump Safety Net
  jump_audit <- dt[is.finite(close_adj_final) & close_adj_final > 0, {
    v <- abs(diff(log(close_adj_final)))
    if (!length(v) || all(!is.finite(v))) .(residual_max_abs_logret = 0, residual_jump_date = as.Date(NA))
    else .(residual_max_abs_logret = as.numeric(v[which.max(v)]), residual_jump_date = refdate[which.max(v) + 1L])
  }, by = symbol]
  jump_audit[, residual_jump_flag := is.finite(residual_max_abs_logret) & residual_max_abs_logret >= cfg$adj_residual_jump_tol_log]
  
  st <- merge(st, jump_audit, by = "symbol", all.x = TRUE)
  st[residual_jump_flag == TRUE, adjustment_state := "suspect_unresolved"]
  
  dt[st, on = "symbol", adjustment_state := i.adjustment_state]
  
  # Build Debug Panel
  panel_debug <- data.table::copy(dt)
  data.table::setnames(panel_debug, c("open","high","low","close"), c("open_raw","high_raw","low_raw","close_raw"))
  data.table::setnames(panel_debug, c("open_adj_final","high_adj_final","low_adj_final","close_adj_final"), c("open","high","low","close"))
  
  # Canonical Output
  panel_model <- panel_debug[, .(symbol, refdate, asset_type, open, high, low, close, turnover, qty, adjustment_state)]
  
  de_validate_contract(panel_model, "panel_adj_model")
  de_validate_contract(panel_debug, "panel_adj_debug")
  
  list(panel_adj_model = panel_model, panel_adj_debug = panel_debug, adjustments_timeline = tl, residual_jump_audit = jump_audit)
}


###############################################################################
### FILE: 07_diagnostics_features.R
###############################################################################
# /data_engine/R/07_diagnostics_features.R

de_compute_symbol_diag_features <- function(dt_sym, horizons_days) {
  dt <- data.table::as.data.table(dt_sym)
  n_obs <- nrow(dt)
  if (n_obs < 30L) return(NULL)
  
  out <- list(symbol = dt$symbol[1], end_refdate = dt$refdate[n_obs], n_obs = n_obs)
  
  dt[, close_prev := data.table::shift(close, 1L)]
  dt[, ret_cc_log := log(close / close_prev)]
  dt[, ret_cc_simple := (close / close_prev) - 1]
  
  for (h in horizons_days) {
    if (h > 1L && (n_obs - h) >= 1L) {
      out[[paste0("ret_", h, "d")]] <- (dt$close[n_obs] / dt$close[n_obs - h]) - 1
      rwin <- dt$ret_cc_log[max(1L, n_obs - h + 1L):n_obs]
      out[[paste0("vol_cc_", h, "d")]] <- stats::sd(rwin[is.finite(rwin)]) * sqrt(252)
    } else {
      out[[paste0("ret_", h, "d")]] <- NA_real_
      out[[paste0("vol_cc_", h, "d")]] <- NA_real_
    }
  }
  
  # Drawdown
  prices <- dt$close[is.finite(dt$close) & dt$close > 0]
  if (length(prices) > 2) {
    cm <- cummax(prices)
    dd <- prices / cm - 1
    out$max_dd <- min(dd)
    out$ulcer_index <- sqrt(mean((dd * 100)^2))
  } else {
    out$max_dd <- NA_real_
    out$ulcer_index <- NA_real_
  }
  
  # Amihud
  valid <- is.finite(dt$ret_cc_simple) & is.finite(dt$turnover) & dt$turnover > 0
  out$amihud <- if (any(valid)) mean(abs(dt$ret_cc_simple[valid]) / dt$turnover[valid], na.rm = TRUE) else NA_real_
  
  data.table::as.data.table(out)
}

de_build_features_diag <- function(panel_adj_model, cfg) {
  dt <- data.table::as.data.table(panel_adj_model)
  data.table::setorder(dt, symbol, refdate)
  syms <- unique(dt$symbol)
  
  res <- lapply(syms, function(s) {
    sdt <- dt[symbol == s]
    max_req <- max(cfg$feature_horizons_days) + 1L
    if (nrow(sdt) > max_req) sdt <- sdt[(.N - max_req + 1):.N]
    de_compute_symbol_diag_features(sdt, cfg$feature_horizons_days)
  })
  
  data.table::rbindlist(res[!vapply(res, is.null, logical(1))], fill = TRUE)
}


###############################################################################
### FILE: 08_pipeline.R
###############################################################################
# /data_engine/R/08_pipeline.R

de_run_data_engine <- function(years = NULL, 
                               start_date = NULL, end_date = NULL, 
                               force_symbols = NULL,
                               manual_events = NULL,
                               overrides = NULL,
                               build_diag_features = TRUE) {
  
  de_require(c("data.table", "dplyr"))
  cfg <- de_get_config(overrides)
  de_log_cfg(cfg)
  
  # 1) Build Universe
  de_log("DE_PIPE:", "Building raw universe...")
  if (!is.null(years)) {
    u_raw <- de_build_universe(years, cfg)
  } else if (!is.null(start_date) && !is.null(end_date)) {
    u_raw <- de_build_universe_window(start_date, end_date, cfg)
  } else {
    stop("Must provide either 'years' or 'start_date/end_date'.")
  }
  
  # 2) Select CA Candidates (Modeling set)
  de_log("DE_PIPE:", "Selecting candidates...")
  # FIX: Pass force_symbols directly into the function so it gets audited properly
  prefilter_res <- de_select_ca_candidates(u_raw, cfg, force_symbols)
  cand <- prefilter_res$candidates
  de_log("DE_PIPE:", "Candidates strictly eligible for modeling: ", length(cand))
  
  # 3) Fetch Yahoo CA
  from_ca <- min(u_raw$refdate, na.rm=TRUE) - 10
  to_ca   <- max(u_raw$refdate, na.rm=TRUE) + 10
  
  ca_raw <- data.table::data.table()
  ca_apply <- data.table::data.table()
  sp_audit <- data.table::data.table()
  ca_quar  <- data.table::data.table()
  
  if (length(cand)) {
    de_log("DE_PIPE:", "Fetching CA Registry...")
    ca_raw <- de_build_ca_registry(cand, from_ca, to_ca, cfg)
    
    # 4) Fix / Snap Splits
    if (nrow(ca_raw) && cfg$enable_split_gap_validation) {
      de_log("DE_PIPE:", "Validating splits vs raw gaps...")
      fix_res <- de_fix_yahoo_splits_by_raw_gap(ca_raw, u_raw, cfg)
      ca_apply <- fix_res$corp_actions_apply
      sp_audit <- fix_res$split_audit
      ca_quar  <- fix_res$quarantine
    } else {
      ca_apply <- ca_raw
    }
  }
  
  # 5) Build Normalized Events
  de_log("DE_PIPE:", "Building normalized events table...")
  ev_apply <- de_build_events(ca_apply, manual_events, cfg)
  
  # 6) Apply Adjustments & Finalize
  de_log("DE_PIPE:", "Applying factors and creating panel...")
  adj_res <- de_build_panel_adjusted(u_raw, ev_apply, cfg)
  
  # 7) Diagnostic Features (Optional)
  feat_diag <- NULL
  if (build_diag_features) {
    de_log("DE_PIPE:", "Computing diagnostic features...")
    feat_diag <- de_build_features_diag(adj_res$panel_adj_model, cfg)
  }
  
  de_log("DE_PIPE:", "Pipeline complete. Returning bundle.")
  
  list(
    panel_adj_model = adj_res$panel_adj_model,
    panel_adj_debug = adj_res$panel_adj_debug,
    events_apply = ev_apply,
    corp_actions_raw = ca_raw,
    corp_actions_apply = ca_apply,
    corp_actions_quarantine = ca_quar,
    split_audit = sp_audit,
    prefilter_audit = prefilter_res$prefilter_audit, # <-- New sidecar added here
    adjustments_timeline = adj_res$adjustments_timeline,
    residual_jump_audit = adj_res$residual_jump_audit,
    features_diag = feat_diag,
    meta = list(config = cfg, date_run = Sys.time(), n_universe = nrow(u_raw), n_candidates = length(cand))
  )
}


